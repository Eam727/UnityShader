
# **渲染管线-几何阶段**

参考自：Unity Shader入门精要，本文为本人 学习笔记，请读者尊重原著版权，多多支持冯乐乐前辈的著作。

几何阶段和光栅化阶段，开发者没有绝对的控制权(但GPU向开发者开放了很多控制权)，其**实现的载体是GPU**。

GPU通过实现流水线化，大大加快了渲染速度。

GPU的渲染流水线接收**顶点数据**作为输入，这些顶点数据由应用阶段加载到显存中，再由DrawCall指定的。这些数据随后被传递给**顶点着色器**。

![GPU流水线](https://i.imgur.com/cK2695g.png)

## 几何阶段

- ### 顶点着色器(Vertex Shader)[完全可编程]

	通常用于实现**顶点的空间变换、顶点着色**等功能。

	顶点着色器的处理单位是顶点，也就是说，**输入进来的每个顶点都会调用一次顶点着色器**。顶点着色器本身不会创建或销毁任何顶点，而且无法得到顶点与顶点之间的关系。如：我们无法知道两个顶点是否处于同一个三角网格。

	但正因为这样的相互独立性，GPU可以利用本身的特性并行化处理每一个顶点，这意味着这一阶段的处理速度会很快。

	![](https://i.imgur.com/M8SnyKw.png)

	**坐标变换：就是对顶点的坐标(即位置)进行某种变换。**顶点着色器可以在这一步中**改变顶点的位置**，这在顶点动画中是非常有用的。例如：我们可以通过改变顶点位置来模拟水面、布料等。

	注意：无论我们在顶点着色器中怎样改变顶点的位置，一个最基本的顶点着色器必须完成的一个工作是，**把顶点坐标从模型空间转换到齐次裁剪空间**。

	想想看，我们在顶点着色器中是不是会看到类似下面的代码：
	*o.pos = mul(UNITY_MVP,v.position)*
	上面这句代码的功能，就是把顶点坐标转换到齐次裁剪坐标系下，接着通常再由硬件做透视除法后，最终得到归一化的设备坐标(NDC)。
	
	![](https://i.imgur.com/rN7Blci.png)
	
	需要注意的是：上图给出的坐标范围是OpenGL同时也是Unity使用的NDC，他的z分量范围在[-1,1]之间，而在DirectX中，NDC的z分量范围是[0,1]。顶点着色器可以有不同的输出方式。最常见的输出途径是经光栅化交给片元着色器进行处理。而在现代的ShaderModel中，它还可以把数据发送给曲面细分着色器或几何着色器。

- ### 曲面细分着色器(Tessellation Sader)[可选]

	用于细分图元。
- ### 几何着色器(Geometry Shader)[可选]

	执行逐图元的着色操作，或被用于产生更多的图元。

- ### 裁剪(Clipping)[可配置,不可编程]

	目的：**将那些不在摄像机视野内的顶点裁剪掉，并剔除某些三角图元的面片。**

	例如，我们可以视野自定义的裁剪平面来配置裁剪区域，也可以通过指令控制裁剪三角图元的正面还是背面。

	一个图元和摄像机视野的关系有3种：完全在视野、部分在视野、完全在视野外。
	完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元不会继续向下传递，因为他们不需要被渲染。而那些部分在视野内的图元需要进行一个处理，就是裁剪。如一条线段的一个顶点在视野内，而另一个顶点不在视野内，那么在视野外部的顶点应该使用一个新的顶点来代替，这个新的顶点位于这条线段和视野边界的交点处。

	由于我们已知在NDC下的顶点位置，即顶点位置在一个立方体内，因此裁剪就变得简单：**只需要将图元裁剪到单位立方体内**。
	
	![](https://i.imgur.com/NSQPHvw.png)

	和顶点着色器不同，这一步是不可编程的，即我们无法通过编程来控制裁剪的过程，而是应硬件上的固定操作，但是我们可以自定义一个裁剪操作来对这一步进行配置。

- ### 屏幕映射[不可配置和编程]

	用于实现逐片元的着色操作。
	任务：**把每个图元的x和y坐标转换到屏幕坐标系(Screen Coordinates)下**。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。

	这一步输入的坐标仍然是三维坐标系下的坐标(范围在单位立方体内)。

	假设，我们需要把场景渲染到一个窗口上，窗口的范围是从最小的窗口(x1,y1)到最大的窗口坐标(x2,y2)，其中x1<x2,y1<y2。由于我们输入的坐标范围在-1到1，因此可以想象到，这个过程实际是一个缩放的过程，如下图。**屏幕映射不会对输入的z坐标做任何处理**。实际上，**屏幕坐标系和z坐标一起构成一个坐标系，叫做窗口坐标系(Window Coordinates)**。这些值会一起被传递到光栅化阶段。
	
	![](https://i.imgur.com/xvtTWVX.png)

	 **屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素有多远。**
	有一个需要注意：屏幕坐标系在OpenGL和DirectX之间的差异问题。OpenGL把屏幕的左下角当成最小的窗口坐标系，而DirectX则定义了屏幕的左下角为最小的窗口坐标值。如下图：

	![](https://i.imgur.com/V3d4Zx8.png)

	**产生这种差异的原因**：微软的窗口都使用了这样的坐标系统，因为这和我们的阅读方式是一致的：从左到右、从上到下，并且很多图像文件也是按照这样的格式进行存储的。
	不管原因为何，差异就这么造成了。留给我们开发者的就是，要时刻小心这样的差异，如果你发现得到的图像是倒转的，那么很有可能就是这个原因造成的。
